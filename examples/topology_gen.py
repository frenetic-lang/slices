#!/usr/bin/python
################################################################################
# The Frenetic Project                                                         #
# frenetic@frenetic-lang.org                                                   #
################################################################################
# Licensed to the Frenetic Project by one or more contributors. See the        #
# NOTICE file distributed with this work for additional information            #
# regarding copyright and ownership. The Frenetic Project licenses this        #
# file to you under the following license.                                     #
#                                                                              #
# Redistribution and use in source and binary forms, with or without           #
# modification, are permitted provided the following conditions are met:       #
# - Redistributions of source code must retain the above copyright             #
#   notice, this list of conditions and the following disclaimer.              #
# - Redistributions in binary form must reproduce the above copyright          #
#   notice, this list of conditions and the following disclaimer in            #
#   the documentation or other materials provided with the distribution.       #
# - The names of the copyright holds and contributors may not be used to       #
#   endorse or promote products derived from this work without specific        #
#   prior written permission.                                                  #
#                                                                              #
# Unless required by applicable law or agreed to in writing, software          #
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT    #
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the     #
# LICENSE file distributed with this work for specific language governing      #
# permissions and limitations under the License.                               #
################################################################################
# /slices/examples/topology_gen.py                                             #
# Tools to generate topologies                                                 #
################################################################################
"""Tools to generate topologies.

Topologies generated are un-finalized, so they may be composed.

All functions accept an argument label='s' by default, and all nodes are named
as 'label_%d_%d_...' where %d is whatever index is appropriate for that node.
If you want to compose these topologies, you should use separate labels for each
subgraph.

indexes start at 0.

Note that other useful graphs may be generated by using NXTopo.from_graph on any
of networkX's diverse set of graph generators.
"""

from nxtopo import NXTopo
from nxtopo import from_graph

# These functions use Mark's generators, which may not be importable if they
# don't have access to his code, so import inside the functions.
def waxman(n, alpha=0.8, beta=0.1):
    import waxman_topo
    return nxtopo.from_graph(waxman_topo.waxman_graph(n, alpha, beta))

def make_id(label, *indexes, **kwargs):
    """Generate an id beginning with label and following with indexes.

    if num=True in kwargs, generate it as a number, keeping indexes separated by
    powers of 10.  In that case, label must be a number
    """
    if 'num' in kwargs and kwargs['num']:
        value = label
        for i in indexes:
            value = (value * 10) + i
        return value
    else:
        if len(indexes) == 0:
            return label
        else:
            if label == '':
                return '_'.join([str(i) for i in indexes])
            else:
                return label + '_' + '_'.join([str(i) for i in indexes])

def grid(m, n, diagonal=False, label='s', num=False):
    """Produce an m by n grid of nodes.

    Diagonal links are not included unles diagonal=True is set.
    """
    topo = NXTopo()

    # add nodes
    for i in range(m):
        for j in range(n):
            topo.add_switch(make_id(label, i, j, num=num))

    # add links
    for i in range(m):
        for j in range(n):
            if i+1 < m:
                topo.add_link(make_id(label, i, j, num=num),
                              make_id(label, i+1, j, num=num))
            if j+1 < n:
                topo.add_link(make_id(label, i, j, num=num),
                              make_id(label, i, j+1, num=num))
            if diagonal:
                if i+1 < m and j+1 < n:
                    topo.add_link(make_id(label, i, j, num=num),
                                  make_id(label, i+1, j+1, num=num))
                if i-1 >= 0 and j+1 < n:
                    topo.add_link(make_id(label, i, j, num=num),
                                  make_id(label, i-1, j+1, num=num))

    return topo

def torus2d(m, n, diagonal=False, label='s', num=False):
    """Produce an m by n 2d torus."""
    topo = grid(m, n, diagonal=diagonal, label=label, num=num)
    for i in range(m):
        topo.add_link(make_id(label, i, 0, num=num), make_id(label, i, n-1, num=num))
        if diagonal:
            for j in range(n):
                topo.add_link(make_id(label, i, j, num=num),
                              make_id(label, (i-1) % m, n-1), num=num)
                topo.add_link(make_id(label, i, j, num=num),
                              make_id(label, (i+1) % m, n-1), num=num)

    for j in range(n):
        topo.add_link(make_id(label, 0, j, num=num),
                      make_id(label, m-1, j, num=num))
        if diagonal:
            for i in range(m):
                topo.add_link(make_id(label, i, j, num=num),
                              make_id(label, m-1, (j-1) % n, num=num))
                topo.add_link(make_id(label, i, j, num=num),
                              make_id(label, m-1, (j+1) % n, num=num))
    return topo

def hierarchy(root, layers, bottom, hosts, label='s', num=False):
    """Build a hierarchical fat tree.

    ARGS:
        root: number of aggregating switches at the root of the tree, connected
            to all the switches of the next layer
        layers: [(groups, aggregators)], in order from closest to root to
            farthest.  At each layer, groups defines the number of divisions of
            the tree, and aggregators the number of aggregator switches
            connected to all the switches of that group in the next layer down.
            This multiplies going downwards, so [(2, 2), (2, 2)] has 4
            aggregator switches total on the first layer, and 8 on the next,
            with 4 groups total at the bottom.
        bottom: the number of switches per group at the last layer of switches
        hosts: the number of hosts per switch at the bottom.

    Numbering:  groups are hierarchical, so a given switch has a sequence of
    numbers as follows:
        * group numbers in order from the root (none of these for the root)
        * sequential number to distinguish between switches/hosts in the group.

    Bottom layer nodes are treated as if they were all in group 0 of the
    previous layer.
    """
    topo = NXTopo()
    if len(layers) > 0:
        layer = layers[0]
        next_layer = hierarchy_add_layer(topo, [], layer, layers[1:],
                                         bottom, hosts, label=label, num=num)
    else:
        next_layer = hierarchy_bottom(topo, [0], bottom, hosts, label=label, num=num)
    for i in range(root):
        s_id = make_id(label, i, num=num)
        topo.add_switch(s_id)
        for s in next_layer:
            topo.add_link(s_id, s)
    return topo

def hierarchy_add_layer(topo, groups, (ngroups, switches),
                        layers, bottom, hosts, label='s', num=False):
    layer_switches = set()
    for g in range(ngroups):
        group_switches = set()
        local_groups = groups + [g]
        for s in range(switches):
            switch = make_id(label, *(local_groups + [s]), num=num)
            group_switches.add(switch)
            if switch in topo.node:
                print "%s already in topo!" % switch
            topo.add_switch(switch)
        layer_switches.update(group_switches)
        if len(layers) > 0:
            # recursive case
            next_layer = layers[0]
            next_switches = hierarchy_add_layer(topo, local_groups, next_layer,
                                                layers[1:], bottom, hosts,
                                                label=label, num=num)
        else:
            # bottom of tree, make bottom switches
            next_switches = hierarchy_bottom(topo, local_groups + [0],
                                             bottom, hosts, label=label,
                                             num=num)
        for g_s in group_switches:
            for n_s in next_switches:
                topo.add_link(g_s, n_s)
    return layer_switches

def hierarchy_bottom(topo, groups, bottom, hosts, label='s', num=False):
    switches = set()
    for s in range(bottom):
        s_id = make_id(label, *(groups + [s]), num=num)
        switches.add(s_id)
        if s_id in topo.node:
            print "%s already in topo!" % s_id
        topo.add_switch(s_id)
        hs = hierarchy_hosts(topo, groups + [s], hosts, label=label, num=num)
        for h in hs:
            topo.add_link(s_id, h)
    return switches

def hierarchy_hosts(topo, groups, hosts, label='s', num=False):
    hs = set()
    for h in range(hosts):
        h_id = make_id(label, *(groups + [h]), num=num)
        hs.add(h_id)
        topo.add_host(h_id)
    return hs
